@title Short proofs of graph non-3-colorability

@s Introduction

This is just a sample introduction to see how the Literate tool works.


--- brett.ts

function helloWorld() {
    console.log('Hello, world 3!');
}

---


@s A few attempts at analogies

**The Student Prankster Problem**
- Imagine you have a university where many students take many classes. A student can be in many classes, and many students can be in one class.
- There are certain rivalries between classes. Some sets of students will go bother other students 



@s The Student Prankster problem

Algorithm:

1. Pick a war and its combatants.
2. Fight through all outcomes.
3. Mark any wars which are now viable or unviable.
4. Recurse.
5. If no solution found, "undo" your last war and pick another. Unmark the viable and unviable wars.

This algorithm only works if there does not exist a sequence of wars which is ambiguous.


A sequence of wars is unambiguous. But it leads to a combinatorial explosion. That means searching for the next wars is easy -- just pick one. But to *verify* a sequence of wars, you ought to have the combatants handy for each war so that it's easy to keep track.

@s A nondeterministic miniKanren algorithm: Verifying that a certain sequence of wars produces a hypergraph of size < 3

--- main.mk.scm
(load "~/miniKanren/mk.scm")

@{The riffle relation}
---

@s
Now we must verify that there is indeed a conflict between $h_1$ and $h_2$. So we must go through $G$ to verify that it contains every edge $(u, v)$ (or $(v, u)$).

- There is a complete bipartite subgraph such that
    - the first half is in h1 and not in h2
    - the second half is in h2 and not in h1
- h3 is the union of the vertices in h1 and h2 that are not in the cbs

Consider 6 disjoint roles that a vertex could be in:

<table>
    <tr>
        <th>Role name</th>
        <th>Included in $e_l$?</th>
        <th>Included in $e_r$?</th>
        <th>Role within the complete bipartite subgraph</th>
        <th>Included in $e_o$?</th>
    </tr>
    <tr>
        <td>$a$</td><td>1</td><td>0</td><td>$L$</td><td>0</td>
    </tr>
    <tr>
        <td>$b$</td><td>0</td><td>1</td><td>$R$</td><td>0</td>
    </tr>
    <tr>
        <td>$u$</td><td>1</td><td>0</td><td>$N$</td><td>1</td>
    </tr>
    <tr>
        <td>$v$</td><td>0</td><td>1</td><td>$N$</td><td>1</td>
    </tr>
    <tr>
        <td>$w$</td><td>1</td><td>1</td><td>$N$</td><td>1</td>
    </tr>
    <tr>
        <td>$o$</td><td>0</td><td>0</td><td>$N$</td><td>0</td>
    </tr>
</table>

Below is an example with six vertices, one in each role and labelled by its role. The left includes the hyperedges $e_l$ and $e_r$, the right includes the hyperedge $e_o$.

![the six roles](../diagrams/the-six-roles.jpg "The six different roles, visualized")


--- main.mk.scm +=
(define roleo (lambda (role el er biclique eo)
    (fresh (x)
        (== x `(,role ,el ,er ,biclique ,eo))
        (conde
            ((== x '(a 1 0 l 0)))
            ((== x '(b 0 1 r 0)))
            ((== x '(u 1 0 o 1)))
            ((== x '(v 0 1 o 1)))
            ((== x '(w 1 1 o 1)))
            ((== x '(o 0 0 o 0)))))))
---

Later, we may want to allow choosing to *not* use an edge in the provided CBS. This would give us flexibility to pass in just the maximal CBSes, rather than all $2^n$ combinations of each CBS.


--- main.mk.scm +=

(define all-roleso (lambda (a b c d e)
    (conde
        ((== `(,a ,b ,c ,d ,e) '(() () () () ())))
        ((fresh (car-a cdr-a car-b cdr-b car-c cdr-c car-d cdr-d car-e cdr-e)
            (== `(,a ,b ,c ,d ,e) `((,car-a . ,cdr-a) (,car-b . ,cdr-b) (,car-c . ,cdr-c) (,car-d . ,cdr-d) (,car-e . ,cdr-e)))
            (roleo car-a car-b car-c car-d car-e)
            (all-roleso cdr-a cdr-b cdr-c cdr-d cdr-e))))))
---

There is a crucial detail missing in the proof step. And that is that $R_1$ and $R_2$ must be nonempty. Therefore it is trusted that the caller passes in cbs with a nonempty **left** and nonempty **right** side.

--- main.mk.scm +=
(define proveso (lambda (hypergraph bicliques steps)
    (conde
        ((== steps '()) (any-less-than-3o hypergraph))
        ((fresh (step rest-steps e1 e2 el er eo rest-hyperedges biclique rest-bicliques filtered-bicliques)
            (== steps `(,step . ,rest-steps))
            ;; Pick two hyperedges
            (riffleo `(,e1 ,e2) rest-hyperedges hypergraph)
            
            ;; Order matters since one will be considered "left" and the other "right"
            (riffleo `(,el) `(,er) `(,e1 ,e2))
            
            ;; Pick one biclique
            (riffleo `(,biclique) rest-bicliques bicliques)

            ;; These hyperedges must be connected
            (all-roleso step el er biclique eo)
            
            (filter-bicliqueso biclique rest-bicliques filtered-bicliques)
            
            ;; Recur on the rest of the steps with the new hypergraph
            (proveso `(,eo . ,rest-hyperedges) filtered-bicliques rest-steps))))))

(define less-than-3o (lambda (hyperedge)
    (fresh (n)
        (conde
            ((== n '(z)))
            ((== n '(s z)))
            ((== n '(s s z))))
            
        (sizeo hyperedge n))))

(define any-less-than-3o (lambda (h)
    (fresh (car-h cdr-h)
        (== h `(,car-h . ,cdr-h))
        (conde
            ((less-than-3o car-h))
            ((any-less-than-3o cdr-h))))))

@{Sizeo}
---

@s Definition of a complete bipartite subgraph
A complete bipartite subgraph in a graph with $n$ vertices can be represented as a list of length $n$, where each element is one of the following.

$L$
: Belongs to the **left** side of the complete bipartite subgraph.

$R$
: Belongs to the **right** side of the complete bipartite subgraph.

$N$
: Neither. Not included in the complete bipartite subgraph.

@s Discarding CBSes with used vertices

--- main.mk.scm +=
(define filter-bicliqueso (lambda (x l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l o-rest)
            (== l `(,car-l . ,cdr-l))
            (conde
                ((== o `(,car-l . ,o-rest))
                    (all-disjointo x car-l))
                ((== o o-rest)
                    (any-overlapo x car-l)))
            (filter-bicliqueso x cdr-l o-rest))))))

(define overlapo (lambda (u v)
    (fresh (x)
        (== x `(,u ,v))
        (conde
            ((== x '(l l)))
            ((== x '(l r)))
            ((== x '(r l)))
            ((== x '(r r)))))))

(define any-overlapo (lambda (x y)
    (fresh (car-x cdr-x car-y cdr-y)
        (== x `(,car-x . ,cdr-x))
        (== y `(,car-y . ,cdr-y))
        (conde
            ((overlapo car-x car-y))
            ((any-overlapo cdr-x cdr-y))))))

(define disjoint2o (lambda (u v)
    (conde
        ((== u 'o))
        ((== v 'o)))))

(define disjointo (lambda (u v)
    (fresh (x)
        (== x `(,u ,v))
        (conde
            ((== x '(l o)))
            ((== x '(r o)))
            ((== x '(o o)))
            ((== x '(o r)))
            ((== x '(o l)))))))
        
(define all-disjointo (lambda (x y)
    (conde
        ((== x '()) (== y '()))
        ((fresh (car-x cdr-x car-y cdr-y)
            (== x `(,car-x . ,cdr-x))
            (== y `(,car-y . ,cdr-y))
            (disjointo car-x car-y)
            (all-disjointo cdr-x cdr-y))))))
---


@s The size of a hyperedge
Since a hypergraph is a 0-1 matrix whose columns are vertices and whose rows are edges which contain those vertices, then the size of a hyperedge (represented as a list) is the number of 1s in it.


--- Sizeo
(define sizeo (lambda (hyperedge size)
    (fresh (rest)
        (conde
            ((== hyperedge '()) (== size '(z)))
            ((== hyperedge `(0 . ,rest)) (sizeo rest size))
            ((== hyperedge `(1 . ,rest)) (sizeo rest `(s . ,size)))))))
---

Applying Will's law

--- Sizeo :=
(define sizeo (lambda (hyperedge size)
    (fresh (first rest size-rec)
        (conde
            ((== hyperedge '()) (== size 'z))
            ((== hyperedge `(,first . ,rest))
                (conde
                    ((== first 0) (== size size-rec))
                    ((== first 1) (== size `(s . ,size-rec))))
                (sizeo rest size-rec))))))
---

@ABC Example

![ABC example](../diagrams/abc-example.jpg "ABC example")

--- main.mk.scm +=
(define abc-hypergraph '(
    (1 0 1 1 0 0 0 0 0)
    (0 1 0 0 1 1 0 0 0)
    (0 0 0 0 0 0 1 1 1)))

(define abc-bicliques '(
    (l r o o o o o o o)
    (o o o o o l r o o)
    (o o o o l o r o o)
    (o o o o l l r o o)
    (o o o l o o r o o)
    (o o o l o l r o o)
    (o o o l l o r o o)
    (o o o l l l r o o)
    (o o l o o o r o o)
    (o o l o o l r o o)
    (o o l o l o r o o)
    (o o l o l l r o o)
    (o o l l o o r o o)
    (o o l l o l r o o)
    (o o l l l o r o o)
    (o o l l l l r o o)))
---

@K4 Example

The simplest example, the base case $K_4$.

--- main.mk.scm +=
(define k4-example-hypergraph '(
    (1 1 1 0)
    (0 1 1 1)))
    
(define k4-example-cbh '(
    (l o o r)))
---

@s Appendix A: The Riffle Relation

Adapted from [here](https://github.com/schreiberbrett/cool-relations/blob/main/the-riffle-relation.md).

--- The riffle relation
(define riffleo (lambda (a b o)
    (fresh (car-a cdr-a car-b cdr-b car-o cdr-o z0 z1)
        (conde
            ;; If `a` and `b` are both empty, then the output is empty.
            ((== a '()) (== b '()) (== o '()))
            
            ;; If `a` is non-empty and `b` is empty, then the output is equal to `a`.
            ((== a `(,car-a . ,cdr-a)) (== b '()) (== o a))
            
            ;; If `a` is empty and `b` is non-empty, then the output is equal to `b`.
            ((== a '()) (== b `(,car-b . ,cdr-b)) (== o b))
            
            ;; When both `a` and `b` are non-empty
            ((== a `(,car-a . ,cdr-a)) (== b `(,car-b . ,cdr-b)) (== o `(,car-o . ,cdr-o))
                (conde
                    ((== car-o car-a) (== z0 cdr-a) (== z1 b))
                    ((== car-o car-b) (== z0 a) (== z1 cdr-b)))
                    
                (riffleo z0 z1 cdr-o))))))
---

Another useful relation

--- main.mk.scm +=
(define same-lengtho (lambda (a b)
    (conde
        ((== a '()) (== b '()))
        ((fresh (x y z w)
            (== a `(,x . ,y))
            (== b `(,z . ,w))
            (same-lengtho y w))))))
---

@s Appendix B: immutable LinkedList implementation with constant-time, linkedList.Remove2Add1()

--- Remove2Add1Test.java
public class Remove2Add1Test {
    public static void Main(String[] args) {
        var dcba = new R2A1LinkedList<String>({"d", "c", "b", "a"});
        
        // Require callers to ensure that i < j
        var eba = dbca.remove2add1(0, 1, "e");
        var fd = edb.remove2add1(0, 2, "f");

        System.out.println("dbca: " + dbca.deepEquals({"d", "b", "c"));
        Syntem.out.println("eda: " + eda.deepEquals({"e", "b", "a"}));
        System.out.println("fd: " + eda.deepEquals({"f", "d"}));
    }
}
---

@s Appendix C: A translation of "proves" into Prolog

Hopefully this makes benchmarking easier. I don't know why filter_cbs is taking so long.

--- main.pl
riffle([], [], []).
riffle([A|As], [], [A|As]).
riffle([], [B|Bs], [B|Bs]).

riffle([A|As], [B|Bs], [A|Os]) :-
    riffle(As, [B|Bs], Os).

riffle([A|As], [B|Bs], [B|Os]) :-
    riffle([A|As], Bs, Os).



proof_step([], [], [], [], []).
proof_step([Step|Steps], 
           [Hleft|Hlefts],
           [Hright|Hrights],
           [C|Cbs],
           [Hout|Houts]) :-
    is_proof_step(Hleft, Hright, Hout, C, Step),
    proof_step(Steps, Hlefts, Hrights, Cbs, Houts).

is_proof_step(0, 0, 0, o, o).
is_proof_step(1, 0, 0, l, r1).
is_proof_step(1, 0, 1, o, b1).
is_proof_step(0, 1, 0, r, r2).
is_proof_step(0, 1, 1, o, b2).
is_proof_step(1, 1, 1, o, b).


proves(H, _, []) :- any_less_than_three(H).
proves(H, Cbs, [Step|Steps]) :-
    riffle([H1, H2], Hrest, H),
    riffle([HL], [HR], [H1, H2]),
    riffle([C], Crest, Cbs),
    proof_step(Step, HL, HR, C, Hout),
    filter_cbs(C, Crest, NewCbs),
    proves([Hout|Hrest], NewCbs, Steps).


any_less_than_three([H|_]) :- less_than_three(H).
any_less_than_three([_|Hs]) :- any_less_than_three(Hs).

less_than_three(X) :- size(X, z).
less_than_three(X) :- size(X, s(z)).
less_than_three(X) :- size(X, s(s(z))).
                           
size([], z).
size([0|Xs], N) :- size(Xs, N).
size([1|Xs], s(N)) :- size(Xs, N).


filter_cbs(_, [], []).
filter_cbs(X, [L|Ls], Os) :-
    does_overlap(X, L),
    filter_cbs(X, Ls, Os).
filter_cbs(X, [L|Ls], [L|Os]) :-
    no_overlap(X, L),
    filter_cbs(X, Ls, Os).

overlaps([], [], f).
overlaps([l|_], [l|_], t).
overlaps([l|_], [r|_], t).
overlaps([r|_], [l|_], t).
overlaps([r|_], [r|_], t).

overlaps([o|Xs], [_|Ys], B) :-
    overlaps(Xs, Ys, B).

overlaps([_|Xs], [o|Ys], B) :-
    overlaps(Xs, Ys, B).


does_overlap([l|_], [l|_]).
does_overlap([l|_], [r|_]).
does_overlap([r|_], [l|_]).
does_overlap([r|_], [r|_]).
does_overlap([_|X], [_|Y]) :- does_overlap(X, Y).

no_overlap([], []).
no_overlap[[o|X], [o|Y]) :- no_overlap(X, Y).
no_overlap([o|X], [l|Y]) :- no_overlap(X, Y).
no_overlap([o|X], [r|Y]) :- no_overlap(X, Y).
no_overlap([l|X], [o|Y]) :- no_overlap(X, Y).
no_overlap([r|X], [o|Y]) :- no_overlap(X, Y).


k4_hypergraph([
	[1, 1, 1, 0],
	[0, 1, 1, 1]]).

k4_cbs([
	[l, o, o, r]]).

abc_hypergraph([
	[1, 0, 1, 1, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 1, 1]]).

abc_cbs([
    [l, r, o, o, o, o, o, o, o],
    [o, o, o, o, o, l, r, o, o],
    [o, o, o, o, l, o, r, o, o],
    [o, o, o, o, l, l, r, o, o],
    [o, o, o, l, o, o, r, o, o],
    [o, o, o, l, o, l, r, o, o],
    % [o, o, o, l, l, o, r, o, o],
    [o, o, l, l, l, l, r, o, o]]).
    
abc_proof(Proof) :- 
    abc_hypergraph(X),
    abc_cbs(Y),
    proves(X, Y, Proof).
    
my_filter(X) :-
    filter_cbs([o, o, o, l, r], [
        [l, o, o, o, l],
        [l, o, o, o, r],
        [l, r, o, o, o]
    ], F).
---


@s A translation of proveso into ramo for Javascript

--- main.ramo.js
import  { run, Rel, conde, exist, eq, conso, nilo } from 'https://esm.sh/ramo';

const appendo = Rel((xs, ys, zs) => conde(
  [nilo(xs), eq(ys, zs)],
  exist((a, d, res) => [
    conso(a, d, xs),
    conso(a, res, zs),
    appendo(d, ys, res)
  ])
));

const roleo = Rel((role, el, er, biclique, eo) => [
    exist((x) => [
        eq(x, [role, el, er, biclique, eo]),
        conde(
            eq(x, ['a', 1, 0, 'l', 0]),
            eq(x, ['b', 0, 1, 'r', 0]),
            eq(x, ['u', 1, 0, 'o', 1]),
            eq(x, ['v', 0, 1, 'o', 1]),
            eq(x, ['w', 1, 1, 'o', 1]),
            eq(x, ['o', 0, 0, 'o', 0]))])])


const allRoleso = Rel((a, b, c, d, e) =>
    conde(
        eq([a, b, c, d, e], [[], [], [], [], []]),
        exist((carA, cdrA, carB, cdrB, carC, cdrC, carD, cdrD, carE, cdrE) => [
            conso(carA, cdrA, a),
            conso(carB, cdrB, b),
            conso(carC, cdrC, c),
            conso(carD, cdrD, d),
            conso(carE, cdrE, e),
            roleo(carA, carB, carC, carD, carE),
            allRoleso(cdrA, cdrB, cdrC, cdrD, cdrE)])))
            
const proveso = Rel((hypergraph, bicliques, steps) =>
    conde(
        [nilo(steps), anyLessThan3o(hypergraph)],
        exist((step, restSteps, e1 e2 el er eo restHyperedges, biclique, restBicliques, filteredBicliques newHypergraph) => [
            conso(step, restSteps, steps),

            // Pick two hyperedges
            riffleo([e1, e2], rest-hyperedges, hypergraph),
            
            // Order matters since one will be considered "left" and the other "right"
            riffleo([el], [er], [e1, e2]),
            
            // Pick one biclique
            riffleo([biclique], restBicliques, bicliques),
            
            // These hyperedges must be connected
            allRoleso(step, el, er, biclique, eo),

            filterBicliqueso(biclique, restBicliques, filteredBicliques),
            
            // Recur on the rest of the steps with the new hypergraph
            conso(eo, restHyperedges, newHypergraph)
            proveso(newHypergarph, filteredBicliques, restSteps)])))

const lessThan3o = Rel((hyperedge) =>
    exist((n) => [
        conde(
            eq(n, ['z']),
            eq(n, ['s', 'z']),
            eq(n, ['s', 's', 'z'])),
            
        sizeo(hyperedge, n)]))
            
const anyLessThan3o = Rel((hypergraph) =>
    exist((hyperedge restHyperedges) => [
        conso(hyperedge, restHyperedges, hypergraph),
        conde(
            lessThan3o(hyperedge),
            anyLessThan3o(restHyperedges))]))

const sizeo = Rel((hyperedge, size) =>
    conde(
        [nilo(hyperedge), eq(sizeo, ['z'])],
        exist((first, rest, sizeRec) => [
            conso(first, rest, hyperedge),
            
            
const filterBicliques = Rel((x, l, o) =>
    conde(
        [nilo(l), nilo(o)],
        fresh((carL, cdrL, oRest) => [
            conso(carL, cdrL, l),
            conde(
                [conso(carL, oRest, o),
                    allDisjointo(x, carL)],
                [eq(o, oRest),
                    anyOverlapo(x, carL)]),
            filterBicliques(x, cdrL, oRest)])))
            
console.log(run()(q => exist((a, b, c, d, e) => [eq(q, [a, b, c, d, e]), roleo(a, b, c, d, e)])))


---

@s Non-3-colorability and odd cycles
Proving a graph $G$ is not 3-colorable involves operations on the odd cycles contained in the graph. Therefore it would be useful to collect a set of sets of vertices, where the outer set contains the inner set if and only if there is an odd cycle in $G$ containing exactly those vertices in the inner set.

A hypergraph would be the most appropriate data structure for representing this set-of-sets since the innermost elements are vertices corresponding to vertices of the original graph $G$. Let's call this an **odd cycle hypergraph** $H$ that can be generated from $G$.

![test](../diagrams/odd-cycle-hypergraph.jpg "an odd cycle hypergraph")

For example, consider the above graph $G$, its 4 odd cycles, and its *odd cycle hypergraph*, $H$, which contains 4 hyperedges. It has 4 odd cycles drawn shown separately. Since two of the hyperedges have the exact same vertices, the hypergraph is [non-simple](https://en.wikipedia.org/wiki/Hypergraph#Properties_of_hypergraphs).


An efficient representation of a hypergraph is to use a two-dimensional boolean array where the rows are hyperedges and the columns are vertices. Each cell  $(e, v)$ holds the value `true` if vertex $v$ is included in the hyper-edge $e$, and `false` otherwise.




