@title Short proofs of graph non-3-colorability

@s Introduction

This is just a sample introduction to see how the Literate tool works.


--- brett.ts

function helloWorld() {
    console.log('Hello, world 3!');
}

---


@s A few attempts at analogies

**The Student Prankster Problem**
- Imagine you have a university where many students take many classes. A student can be in many classes, and many students can be in one class.
- There are certain rivalries between classes. Some sets of students will go bother other students 



@s The Student Prankster problem

Algorithm:

1. Pick a war and its combatants.
2. Fight through all outcomes.
3. Mark any wars which are now viable or unviable.
4. Recurse.
5. If no solution found, "undo" your last war and pick another. Unmark the viable and unviable wars.

This algorithm only works if there does not exist a sequence of wars which is ambiguous.


A sequence of wars is unambiguous. But it leads to a combinatorial explosion. That means searching for the next wars is easy -- just pick one. But to *verify* a sequence of wars, you ought to have the combatants handy for each war so that it's easy to keep track.

@s A nondeterministic miniKanren algorithm: Verifying that a certain sequence of wars produces a hypergraph of size < 3

--- main.mk.scm
(load "~/miniKanren/mk.scm")

@{The riffle relation}
---

--- main.pl
% File declaration for any translations into Prolog
---

@s
Now we must verify that there is indeed a conflict between $h_1$ and $h_2$. So we must go through $G$ to verify that it contains every edge $(u, v)$ (or $(v, u)$).

- There is a complete bipartite subgraph such that
    - the first half is in h1 and not in h2
    - the second half is in h2 and not in h1
- h3 is the union of the vertices in h1 and h2 that are not in the cbs

Consider 6 disjoint roles that a vertex could be in:

<table>
    <tr>
        <th>Role name</th>
        <th>Included in $e_l$?</th>
        <th>Included in $e_r$?</th>
        <th>Role within the complete bipartite subgraph</th>
        <th>Included in $e_o$?</th>
    </tr>
    <tr>
        <td>$a$</td><td>1</td><td>0</td><td>$L$</td><td>0</td>
    </tr>
    <tr>
        <td>$b$</td><td>0</td><td>1</td><td>$R$</td><td>0</td>
    </tr>
    <tr>
        <td>$u$</td><td>1</td><td>0</td><td>$N$</td><td>1</td>
    </tr>
    <tr>
        <td>$v$</td><td>0</td><td>1</td><td>$N$</td><td>1</td>
    </tr>
    <tr>
        <td>$w$</td><td>1</td><td>1</td><td>$N$</td><td>1</td>
    </tr>
    <tr>
        <td>$o$</td><td>0</td><td>0</td><td>$N$</td><td>0</td>
    </tr>
</table>

Below is an example with six vertices, one in each role and labelled by its role. The left includes the hyperedges $e_l$ and $e_r$, the right includes the hyperedge $e_o$.

![the six roles](../diagrams/the-six-roles-formally.png "The six different roles, visualized")


--- main.mk.scm +=
(define roleo (lambda (role el er biclique eo)
    (fresh (x)
        (== x `(,role ,el ,er ,biclique ,eo))
        (conde
            ((== x '(a 1 0 l 0)))
            ((== x '(b 0 1 r 0)))
            ((== x '(u 1 0 o 1)))
            ((== x '(v 0 1 o 1)))
            ((== x '(w 1 1 o 1)))
            ((== x '(o 0 0 o 0)))))))
---

Later, we may want to allow choosing to *not* use an edge in the provided CBS. This would give us flexibility to pass in just the maximal CBSes, rather than all $2^n$ combinations of each CBS.


--- main.mk.scm +=

(define all-roleso (lambda (a b c d e)
    (conde
        ((== `(,a ,b ,c ,d ,e) '(() () () () ())))
        ((fresh (car-a cdr-a car-b cdr-b car-c cdr-c car-d cdr-d car-e cdr-e)
            (== `(,a ,b ,c ,d ,e) `((,car-a . ,cdr-a) (,car-b . ,cdr-b) (,car-c . ,cdr-c) (,car-d . ,cdr-d) (,car-e . ,cdr-e)))
            (roleo car-a car-b car-c car-d car-e)
            (all-roleso cdr-a cdr-b cdr-c cdr-d cdr-e))))))
---

There is a crucial detail missing in the proof step. And that is that $R_1$ and $R_2$ must be nonempty. Therefore it is trusted that the caller passes in cbs with a nonempty **left** and nonempty **right** side.


@s A proof protocol
A **proof protocol** is a list of stups such that each step is a triple $(u, v, b)$ such that $u$, $v$ are distinct hyperedges in $H$ and $b$ is a biclique over a subset of the disjoint vertices in $u$ to the disjoint vertices in $v$.

Each step combines two hyperedges into one, using a biclique. Or, from an immutable perspective, it creates a new hypergraph with two less hyperedges and one additional.

--- main.mk.scm +=
(define proveso (lambda (hypergraph bicliques steps)
    (conde
        ((== steps '()) (any-less-than-3o hypergraph))
        ((fresh (step rest-steps e1 e2 el er eo rest-hyperedges biclique rest-bicliques filtered-bicliques _a _b)
            (== steps `(,step . ,rest-steps))
            ;; Pick two hyperedges
            (riffleo `(,e1 ,e2) rest-hyperedges hypergraph)
            
            ;; Order matters since one will be considered "left" and the other "right"
            (riffleo `(,el) `(,er) `(,e1 ,e2))
            
            ;; Pick one biclique
            (riffleo `(,biclique) rest-bicliques bicliques)

			;; The proof step must have an l and r (sometimes useful)
			;; (riffleo '(l) _a step)
			;; (riffleo '(r) _b step)

            ;; These hyperedges must be connected
            (all-roleso step el er biclique eo)
            
            (filter-bicliqueso biclique rest-bicliques filtered-bicliques)
            
            ;; Recur on the rest of the steps with the new hypergraph
            (proveso `(,eo . ,rest-hyperedges) filtered-bicliques rest-steps))))))

(define less-than-3o (lambda (hyperedge)
    (fresh (n)
        (conde
            ((== n '(z)))
            ((== n '(s z)))
            ((== n '(s s z))))
            
        (sizeo hyperedge n))))

(define any-less-than-3o (lambda (h)
    (fresh (car-h cdr-h)
        (== h `(,car-h . ,cdr-h))
        (conde
            ((less-than-3o car-h))
            ((any-less-than-3o cdr-h))))))

@{Sizeo}
---

@s Definition of a complete bipartite subgraph
A complete bipartite subgraph in a graph with $n$ vertices can be represented as a list of length $n$, where each element is one of the following.

$L$
: Belongs to the **left** side of the complete bipartite subgraph.

$R$
: Belongs to the **right** side of the complete bipartite subgraph.

$N$
: Neither. Not included in the complete bipartite subgraph.

@s Discarding CBSes with used vertices

--- main.mk.scm +=
(define filter-bicliqueso (lambda (x l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l o-rest)
            (== l `(,car-l . ,cdr-l))
            (conde
                ((== o `(,car-l . ,o-rest))
                    (all-disjointo x car-l))
                ((== o o-rest)
                    (any-overlapo x car-l)))
            (filter-bicliqueso x cdr-l o-rest))))))

(define overlapo (lambda (u v)
    (fresh (x)
        (== x `(,u ,v))
        (conde
            ((== x '(l l)))
            ((== x '(l r)))
            ((== x '(r l)))
            ((== x '(r r)))))))

(define any-overlapo (lambda (x y)
    (fresh (car-x cdr-x car-y cdr-y)
        (== x `(,car-x . ,cdr-x))
        (== y `(,car-y . ,cdr-y))
        (conde
            ((overlapo car-x car-y))
            ((any-overlapo cdr-x cdr-y))))))

(define disjoint2o (lambda (u v)
    (conde
        ((== u 'o))
        ((== v 'o)))))

(define disjointo (lambda (u v)
    (fresh (x)
        (== x `(,u ,v))
        (conde
            ((== x '(l o)))
            ((== x '(r o)))
            ((== x '(o o)))
            ((== x '(o r)))
            ((== x '(o l)))))))
        
(define all-disjointo (lambda (x y)
    (conde
        ((== x '()) (== y '()))
        ((fresh (car-x cdr-x car-y cdr-y)
            (== x `(,car-x . ,cdr-x))
            (== y `(,car-y . ,cdr-y))
            (disjointo car-x car-y)
            (all-disjointo cdr-x cdr-y))))))
---


@s The size of a hyperedge
Since a hypergraph is a 0-1 matrix whose columns are vertices and whose rows are edges which contain those vertices, then the size of a hyperedge (represented as a list) is the number of 1s in it.


--- Sizeo
(define sizeo (lambda (hyperedge size)
    (fresh (rest)
        (conde
            ((== hyperedge '()) (== size '(z)))
            ((== hyperedge `(0 . ,rest)) (sizeo rest size))
            ((== hyperedge `(1 . ,rest)) (sizeo rest `(s . ,size)))))))
---

Applying **the correctness-preserving transformation**.

--- Sizeo :=
(define sizeo (lambda (hyperedge size)
    (conde
        ((== hyperedge '()) (== size '(z)))
        ((fresh (first rest size-rec)
            (== hyperedge `(,first . ,rest))
            (conde
                ((== first 0) (== size size-rec))
                ((== first 1) (== size `(s . ,size-rec))))
            (sizeo rest size-rec))))))
---

@s Verifying the biclique is in the graph

Assume the given graph is lexicographically ordered. So when it is riffled, the edges in the biclique are also lexicographically ordered.

--- main.mk.scm +=


(define all-has-botho (lambda (proof-string biclique-edges)
    (conde
        ((== biclique-edges '()))
        ((fresh (car-l cdr-l)
            (== biclique-edges `(,car-l . ,cdr-l))
            (has-botho proof-string car-l)
            (all-has-botho proof-string cdr-l))))))
            
(define has-botho (lambda (proof-string edge)
    (fresh (x) ;; Needed for some reason to complete the conjunction
        (has-lo proof-string edge)
        (has-ro proof-string edge))))
                
(define has-lo (lambda (proof-string edge)
    (fresh (car-proof-string cdr-proof-string car-edge cdr-edge)
        (== proof-string `(,car-proof-string . ,cdr-proof-string))
        (== edge `(,car-edge . ,cdr-edge))
        (conde
            ((== car-proof-string 'l) (== car-edge 1))
            ((has-lo cdr-proof-string cdr-edge))))))

(define has-ro (lambda (proof-string edge)
    (fresh (car-proof-string cdr-proof-string car-edge cdr-edge)
        (== proof-string `(,car-proof-string . ,cdr-proof-string))
        (== edge `(,car-edge . ,cdr-edge))
        (conde
            ((== car-proof-string 'r) (== car-edge 1))
            ((has-ro cdr-proof-string cdr-edge))))))


(define all-pairso (lambda (l out)
    (conde
        ((fresh (a b)
            (== l `(,a ,b)) (== out `((,a ,b)))))
            
        ((fresh (a b c)
            (== l `(,a ,b ,c))
            (== out `((,a ,b) (,a ,c) (,b ,c)))))
        
        ((fresh (a b c cdr-l out-rec my-pairs)
            (== l `(,a ,b ,c . ,cdr-l))
            (prefix-allo a `(,b ,c . ,cdr-l) my-pairs)
            (appendo my-pairs out-rec out)
            (all-pairso `(,b ,c . ,cdr-l) out-rec))))))

(define graph-has-bicliqueso (lambda (proof-string graph)
    (fresh (pairs filtered-pairs edges rest-graph)
        (all-pairs-indexedo proof-string pairs)
        (filter-is-lr-pairo pairs filtered-pairs)
        (map-needed-edgeo filtered-pairs edges)
        (riffleo edges rest-graph graph))))
            
(define filter-is-lr-pairo (lambda (l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l cdr-o)
            (== l `(,car-l . ,cdr-l))
            
            (conde
                ((== o `(,car-l . ,cdr-o))
                    (is-lr-pairo car-l))
                ((== o cdr-o)
                    (not-is-lr-pairo car-l)))
            
            (filter-is-lr-pairo cdr-l cdr-o))))))

(define is-lr-pairo (lambda (indexed-pair)
    (fresh (l1 x l2 y l3 z)
        (== indexed-pair `(,l1 ,x ,l2 ,y ,l3))
        (== z `(,x ,y))
        (conde
            ((== z '(l r)))
            ((== z '(r l)))))))
            
(define not-is-lr-pairo (lambda (indexed-pair)
    (fresh (l1 x l2 y l3 z)
        (== indexed-pair `(,l1 ,x ,l2 ,y ,l3))
        (== z `(,x ,y))
        (conde
            ((== x '(l l)))
            ((== x '(o l)))
            ((== z '(l o)))
            ((== z '(o o)))
            ((== z '(r o)))
            ((== z '(o r)))
            ((== z '(r r)))))))

(define map-needed-edgeo (lambda (l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l car-o cdr-o)
            (== l `(,car-l . ,cdr-l))
            (== o `(,car-o . ,cdr-o))
            (needed-edgeo car-l car-o)
            (map-needed-edgeo cdr-l cdr-o))))))


(define needed-edgeo (lambda (indexed-pair edge)
    (fresh (l1 x l2 y l3 l1-zeroes l2-zeroes l3-zeroes o1o o1o1o)
        (== indexed-pair `(,l1 ,x ,l2 ,y ,l3))
        (== o1o1o edge)
        (map-zeroo l1 l1-zeroes)
        (map-zeroo l2 l2-zeroes)
        (map-zeroo l3 l3-zeroes)
        (appendo l1-zeroes `(1 . ,l2-zeroes) o1o)
        (appendo o1o `(1 . ,l3-zeroes) o1o1o))))
        
(define map-zeroo (lambda (l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l car-o cdr-o)
            (== l `(,car-l . ,cdr-l))
            (== o `(,car-o . ,cdr-o))
            (zeroo car-o)
            (map-zeroo cdr-l cdr-o))))))

(define zeroo (lambda (x)
    (== x 0)))
            
(define prefixo (lambda (x l o)
    (== o `(,x ,l))))

(define prefix-allo (lambda (x l o)
    (conde
        ((==  l '()) (== o '()))
        ((fresh (car-l cdr-l car-o cdr-o)
            (== l `(,car-l . ,cdr-l))
            (== o `(,car-o . ,cdr-o))
            (prefixo x car-l car-o)
            (prefix-allo x cdr-l cdr-o))))))

(define appendo (lambda (l r o)
    (conde
        ((== l '()) (== r o))
        ((fresh (car-l cdr-l cdr-o)
            (== l `(,car-l . ,cdr-l))
            (== o `(,car-l . ,cdr-o))
            (appendo cdr-l r cdr-o))))))
---

@s ABC Example

![ABC example](../diagrams/abc-example-formal.png "ABC example")

--- main.mk.scm +=
(define abc-hypergraph '(
    (1 0 1 1 0 0 0 0 0)
    (0 1 0 0 1 1 0 0 0)
    (0 0 0 0 0 0 1 1 1)))

(define abc-bicliques '(
    (l r o o o o o o o)
    (o o o o o l r o o)
    (o o o o l o r o o)
    (o o o o l l r o o)
    (o o o l o o r o o)
    (o o o l o l r o o)
    (o o o l l o r o o)
    (o o o l l l r o o)
    (o o l o o o r o o)
    (o o l o o l r o o)
    (o o l o l o r o o)
    (o o l o l l r o o)
    (o o l l o o r o o)
    (o o l l o l r o o)
    (o o l l l o r o o)
    (o o l l l l r o o)))
    
    
(define failure-hypergraph '(
	(1 1 1 0 0 0 0 0 0 0 0)
	(0 0 0 1 1 1 0 0 0 0 0)
	(0 0 0 0 0 0 1 1 1 1 1)))
	
(define failure-bicliques '(
	(o o l r o o o o o o o)
	(o o o o o l r o o o o)))
---

@s Using a zipper list

How do you iterate through a list while "saving your spot"? One solution is to use a [zipper list](https://en.wikipedia.org/wiki/Zipper_(data_structure)). A zipper list here is defined as a triple $(l, x, r) : ([a], a, [a])$  where $l$ is a list of elements left of focus, $x$ is the element in focus, and $r$ is the list of elements to the right of the element.

A relationship between a zipper-list and its "unfocused" list representation is as follows.

--- main.mk.scm +=
(define is-zipper-listo (lambda (zipper-list list)
    (fresh (l x r)
        (== zipper-list `(,l ,x ,r))
        (appendo l `(,x . ,r) list))))
---

This is especially useful for context-aware "forall" assertions in miniKanren. As such we need a way to generate a list of all focuses from a given list. Thus it would have the type: $[a] \rightarrow [([a], a, [a])]$.

A search of this type signature in [Hoogle](https://hoogle.haskell.org/?hoogle=%5Ba%5D%20-%3E%20%5B(%5Ba%5D%2C%20a%2C%20%5Ba%5D)%5D), gives the [splitEverywhere](https://hackage.haskell.org/package/utility-ht-0.0.16/docs/Data-List-HT.html#v:splitEverywhere) function, which does exactly this.

--- main.mk.scm +=
;; i.e, (windowo '(a b c) '((() a (b c)) ((a) b (c)) ((a b) c ())))
(define windowo (lambda (l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l car-o cdr-o cdr-l-zipper-lists)
            (== l `(,car-l . ,cdr-l))
            (== o `(,car-o . ,cdr-o))
            (== car-o `(() ,car-l ,cdr-l))
            (map-shoveo car-l cdr-l-zipper-lists cdr-o)
            (windowo cdr-l cdr-l-zipper-lists))))))

(define shoveo (lambda (a l o)
    (fresh (left x right)
        (== l `(,left ,x ,right))
        (== o `((,a . ,left) ,x ,right)))))
---

--- main.pl +=
window([], []).

window([CarL|CdrL], [CarO|CdrO]) :-
    CarO = [[], CarL, CdrL],
    mapShove(CarL, CdrLZipperLists, CdrO),
    window(CdrL, CdrLZipperLists).
    
shove(A, L, O) :-
    L = [Left, X, Right],
    O = [[A|Left], X, Right].
---

Let's extend this zipper idea to one that has **two** focuses instead of just one. This double zipper list $(l, x, m, y, r) : ([a], a, [a], a, [a])$ where $l, m, r$ are the interspersed lists and $x, y$ are the two foci. For terseness we call the double zipper list an *indexed pair*.

--- main.mk.scm +=
(define window2o (lambda (l o)
    (fresh (zipper-lists)
        (windowo l zipper-lists)
        (flatmap-window2-helpero zipper-lists o))))

(define window2-helpero (lambda (zipper-list indexed-pairs)
    (fresh (l x r triples)
        (== zipper-list `(,l ,x ,r))
        (windowo r triples)
        (map-make-indexed-pairo l x triples indexed-pairs))))

(define make-indexed-pairo (lambda (l x triple o)
    (fresh (m y r)
        (== triple `(,m ,y ,r))
        (== o `(,l ,x ,m ,y ,r)))))
---

--- main.pl +=
window2(L, O) :-
    window(L, ZipperLists),
    flatmapWindow2Helper(ZipperLists, O).
    
window2Helper(ZipperList, IndexedPairs) :-
    ZipperList = [L, X, R],
    window(R, Triples),
    mapMakeIndexedPair(L, X, Triples, IndexedPairs).
    
makeIndexedPair(L, X, [M, Y, R], [L, X, M, Y, R]).
---

And the relevant map/flatmap implementations

--- main.mk.scm +=
(define flatmap-window2-helpero (lambda (l o)
    (conde
        ((== l '()) (== o '()))
        
        ((fresh (car-l cdr-l o-left o-right)
            (== l `(,car-l . ,cdr-l))
            (window2-helpero car-l o-left)
            (appendo o-left o-right o)
            (flatmap-window2-helpero cdr-l o-right))))))

(define map-shoveo (lambda (a l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l car-o cdr-o)
            (== l `(,car-l . ,cdr-l))
            (== o `(,car-o . ,cdr-o))
            (shoveo a car-l car-o)
            (map-shoveo a cdr-l cdr-o))))))

(define map-make-indexed-pairo (lambda (l x triples o)
    (conde
        ((== triples '()) (== o '()))
        ((fresh (car-triples cdr-triples car-o cdr-o)
            (== triples `(,car-triples . ,cdr-triples))
            (== o `(,car-o . ,cdr-o))
            (make-indexed-pairo l x car-triples car-o)
            (map-make-indexed-pairo l x cdr-triples cdr-o))))))
---

--- main.pl +=
flatmapWindow2Helper([], []).
flatmapWindow2Helper([CarL|CdrL], O) :-
    window2Helper(CarL, OLeft),
    append(OLeft, ORight, O),
    flatmapWindow2Helper(CdrL, ORight).
    
mapShove(_, [], []).
mapShove(A, [CarL|CdrL], [CarO|CdrO]) :-
    shove(A, CarL, CarO),
    mapShove(A, CdrL, CdrO).
    
mapMakeIndexedPair(_, _, [], []).
mapMakeIndexedPair(L, X, [CarTriples|CdrTriples], [CarO, CdrO]) :-
    makeIndexedPair(L, X, CarTriples, CarO),
    mapMakeIndexedPair(L, X, CdrTriples, CdrO).
---

@s Implementing flatmap

To demonstrate flatmap, we need a suitable relation between an object and a list. A number and its multiset of primes is a good candidate relation.
Since this is just a sample, I will only consider the numbers 1 through 9.

--- main.mk.scm +=
(define prime-factorso (lambda (x primes)
    (fresh (y)
        (== y `(,x ,primes))
        (conde
            ((== y '(1 ())))
            ((== y '(2 (2))))
            ((== y '(3 (3))))
            ((== y '(4 (2 2))))
            ((== y '(5 (5))))
            ((== y '(6 (2 3))))
            ((== y '(7 (7))))
            ((== y '(8 (2 2 2))))
            ((== y '(9 (3 3))))))))
---

Now we can write a flatmap function specialized for primeso.

--- main.mk.scm +=
(define flatmap-prime-factorso (lambda (l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l o-left o-right)
            (== l `(,car-l . ,cdr-l))
            (prime-factorso car-l o-left)
            (appendo o-left o-right o)
            (flatmap-prime-factorso cdr-l o-right))))))
---

@s K4 Example

The simplest example, the base case $K_4$.

--- main.mk.scm +=
(define k4-example-hypergraph '(
    (1 1 1 0)
    (0 1 1 1)))
    
(define k4-example-cbh '(
    (l o o r)))
---

@s Appendix A: The Riffle Relation

Adapted from [here](https://github.com/schreiberbrett/cool-relations/blob/main/the-riffle-relation.md).

--- The riffle relation
(define riffleo (lambda (a b o)
    (fresh (car-a cdr-a car-b cdr-b car-o cdr-o z0 z1)
        (conde
            ;; If `a` and `b` are both empty, then the output is empty.
            ((== a '()) (== b '()) (== o '()))
            
            ;; If `a` is non-empty and `b` is empty, then the output is equal to `a`.
            ((== a `(,car-a . ,cdr-a)) (== b '()) (== o a))
            
            ;; If `a` is empty and `b` is non-empty, then the output is equal to `b`.
            ((== a '()) (== b `(,car-b . ,cdr-b)) (== o b))
            
            ;; When both `a` and `b` are non-empty
            ((== a `(,car-a . ,cdr-a)) (== b `(,car-b . ,cdr-b)) (== o `(,car-o . ,cdr-o))
                (conde
                    ((== car-o car-a) (== z0 cdr-a) (== z1 b))
                    ((== car-o car-b) (== z0 a) (== z1 cdr-b)))
                    
                (riffleo z0 z1 cdr-o))))))
---


@s The riffle relation in one direction (for use in non-relational languages)

--- Main.hs
unriffle :: [a] -> [([a], [a])]
unriffle [] = [([], [])]
unriffle (x:xs) = do
    (l, r) <- unriffle xs
    result <- [(x:l, r), (l, x:r)]
    return result
---

Python is very translateable from the Haskell, since it also supports list comprehensions.

--- main.py +=
def unriffle(o: List[T]) -> List[Tuple[List[T], List[T]]]:
	if len(o) == 0:
		return [([], [])]
		
	car_o, cdr_o = o[0], o[1:]
	
	return [
		(l, r)
		for cdr_l, cdr_r in unriffle(cdr_o)
		for l, r in [
			([car_o] + cdr_l, cdr_r),
			(cdr_l, [car_o] + cdr_r)
		]
	]
---

TypeScript does not support list comprehensions, so it is transformed into a more traditional for-loop style.

--- main.ts +=
function unriffle<T>(o: Array<T>): Array<[Array<T>, Array<T>]> {
	if (o.length === 0) {
		return [[[], []]];
	}
	
	const [carO, ...cdrO] = o
	
	let result = new Array<[Array<T>, Array<T>]>();
	
	for (let [cdrL, cdrR] of unriffle(cdrO)) {
		for (let [l, r] of [ [[carO, ...cdrL], cdrR], [cdrL, [carO, ...cdrR]] ]) {
			result.push([l, r]);
		}
	}
	
	return result;
}
---

Another useful relation

--- main.mk.scm +=
(define same-lengtho (lambda (a b)
    (conde
        ((== a '()) (== b '()))
        ((fresh (x y z w)
            (== a `(,x . ,y))
            (== b `(,z . ,w))
            (same-lengtho y w))))))
---

@s Appendix B: immutable LinkedList implementation with constant-time, linkedList.Remove2Add1()

--- Remove2Add1Test.java
public class Remove2Add1Test {
    public static void Main(String[] args) {
        var dcba = new R2A1LinkedList<String>({"d", "c", "b", "a"});
        
        // Require callers to ensure that i < j
        var eba = dbca.remove2add1(0, 1, "e");
        var fd = edb.remove2add1(0, 2, "f");

        System.out.println("dbca: " + dbca.deepEquals({"d", "b", "c"));
        Syntem.out.println("eda: " + eda.deepEquals({"e", "b", "a"}));
        System.out.println("fd: " + eda.deepEquals({"f", "d"}));
    }
}
---

@s Appendix C: A translation of "proves" into Prolog

Hopefully this makes benchmarking easier. I don't know why filter_cbs is taking so long.

--- main.pl +=
riffle([], [], []).
riffle([A|As], [], [A|As]).
riffle([], [B|Bs], [B|Bs]).

riffle([A|As], [B|Bs], [A|Os]) :-
    riffle(As, [B|Bs], Os).

riffle([A|As], [B|Bs], [B|Os]) :-
    riffle([A|As], Bs, Os).



proof_step([], [], [], [], []).
proof_step([Step|Steps], 
           [Hleft|Hlefts],
           [Hright|Hrights],
           [C|Cbs],
           [Hout|Houts]) :-
    is_proof_step(Hleft, Hright, Hout, C, Step),
    proof_step(Steps, Hlefts, Hrights, Cbs, Houts).

is_proof_step(0, 0, 0, o, o).
is_proof_step(1, 0, 0, l, r1).
is_proof_step(1, 0, 1, o, b1).
is_proof_step(0, 1, 0, r, r2).
is_proof_step(0, 1, 1, o, b2).
is_proof_step(1, 1, 1, o, b).


proves(H, _, []) :- any_less_than_three(H).
proves(H, Cbs, [Step|Steps]) :-
    riffle([H1, H2], Hrest, H),
    riffle([HL], [HR], [H1, H2]),
    riffle([C], Crest, Cbs),
    proof_step(Step, HL, HR, C, Hout),
    filter_cbs(C, Crest, NewCbs),
    proves([Hout|Hrest], NewCbs, Steps).


any_less_than_three([H|_]) :- less_than_three(H).
any_less_than_three([_|Hs]) :- any_less_than_three(Hs).

less_than_three(X) :- size(X, z).
less_than_three(X) :- size(X, s(z)).
less_than_three(X) :- size(X, s(s(z))).
                           
size([], z).
size([0|Xs], N) :- size(Xs, N).
size([1|Xs], s(N)) :- size(Xs, N).


filter_cbs(_, [], []).
filter_cbs(X, [L|Ls], Os) :-
    does_overlap(X, L),
    filter_cbs(X, Ls, Os).
filter_cbs(X, [L|Ls], [L|Os]) :-
    no_overlap(X, L),
    filter_cbs(X, Ls, Os).

overlaps([], [], f).
overlaps([l|_], [l|_], t).
overlaps([l|_], [r|_], t).
overlaps([r|_], [l|_], t).
overlaps([r|_], [r|_], t).

overlaps([o|Xs], [_|Ys], B) :-
    overlaps(Xs, Ys, B).

overlaps([_|Xs], [o|Ys], B) :-
    overlaps(Xs, Ys, B).


does_overlap([l|_], [l|_]).
does_overlap([l|_], [r|_]).
does_overlap([r|_], [l|_]).
does_overlap([r|_], [r|_]).
does_overlap([_|X], [_|Y]) :- does_overlap(X, Y).

no_overlap([], []).
no_overlap[[o|X], [o|Y]) :- no_overlap(X, Y).
no_overlap([o|X], [l|Y]) :- no_overlap(X, Y).
no_overlap([o|X], [r|Y]) :- no_overlap(X, Y).
no_overlap([l|X], [o|Y]) :- no_overlap(X, Y).
no_overlap([r|X], [o|Y]) :- no_overlap(X, Y).


k4_hypergraph([
	[1, 1, 1, 0],
	[0, 1, 1, 1]]).

k4_cbs([
	[l, o, o, r]]).

abc_hypergraph([
	[1, 0, 1, 1, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 1, 1]]).

abc_cbs([
    [l, r, o, o, o, o, o, o, o],
    [o, o, o, o, o, l, r, o, o],
    [o, o, o, o, l, o, r, o, o],
    [o, o, o, o, l, l, r, o, o],
    [o, o, o, l, o, o, r, o, o],
    [o, o, o, l, o, l, r, o, o],
    % [o, o, o, l, l, o, r, o, o],
    [o, o, l, l, l, l, r, o, o]]).
    
abc_proof(Proof) :- 
    abc_hypergraph(X),
    abc_cbs(Y),
    proves(X, Y, Proof).
---


@s A translation of proveso into ramo for Javascript

--- main.ramo.js
import  { run, Rel, conde, exist, eq, conso, nilo } from 'https://esm.sh/ramo';

const riffleo = Rel((a, b, o) =>
    exist((carA, cdrA, carB, cdrB, carO, cdrO, z0, z1) =>
        conde(
            // If `a` and `b` are both empty, then the output is empty
            [nilo(a), nilo(b), nilo(o)],
            
            // If `a` is non-empty and `b` is empty, then the output is equal to `a`.
            [conso(carA, cdrA, a), nilo(b), eq(o, a)],
            
            // If `a` is empty and `b` is non-empty, then the output is equal to `b`.
            [nilo(a), conso(carB, cdrB, b), eq(o, b)],
            
            // When both `a` and `b` are non-empty
            [conso(carA, cdrA, a), conso(carB, cdrB, b), conso(carO, cdrO, o),
                conde(
                    [eq(carO, carA), eq(z0, cdrA), eq(z1, b)],
                    [eq(carO, carB), eq(z0, a), eq(z1, cdrB)]),
                    
                riffleo(z0, z1, cdrO)])))

const roleo = Rel((role, el, er, biclique, eo) => [
    exist((x) => [
        eq(x, [role, el, er, biclique, eo]),
        conde(
            eq(x, ['a', 1, 0, 'l', 0]),
            eq(x, ['b', 0, 1, 'r', 0]),
            eq(x, ['u', 1, 0, 'o', 1]),
            eq(x, ['v', 0, 1, 'o', 1]),
            eq(x, ['w', 1, 1, 'o', 1]),
            eq(x, ['o', 0, 0, 'o', 0]))])])


const allRoleso = Rel((a, b, c, d, e) =>
    conde(
        eq([a, b, c, d, e], [[], [], [], [], []]),
        exist((carA, cdrA, carB, cdrB, carC, cdrC, carD, cdrD, carE, cdrE) => [
            conso(carA, cdrA, a),
            conso(carB, cdrB, b),
            conso(carC, cdrC, c),
            conso(carD, cdrD, d),
            conso(carE, cdrE, e),
            roleo(carA, carB, carC, carD, carE),
            allRoleso(cdrA, cdrB, cdrC, cdrD, cdrE)])))
            
const proveso = Rel((hypergraph, bicliques, steps) =>
    conde(
        [nilo(steps), anyLessThan3o(hypergraph)],
        exist((step, restSteps, e1, e2, el, er, eo, restHyperedges, biclique, restBicliques, filteredBicliques, newHypergraph) => [
            conso(step, restSteps, steps),

            // Pick two hyperedges
            riffleo([e1, e2], restHyperedges, hypergraph),
            
            // Order matters since one will be considered "left" and the other "right"
            riffleo([el], [er], [e1, e2]),
            
            // Pick one biclique
            riffleo([biclique], restBicliques, bicliques),
            
            // These hyperedges must be connected
            allRoleso(step, el, er, biclique, eo),

            filterBicliqueso(biclique, restBicliques, filteredBicliques),
            
            // Recur on the rest of the steps with the new hypergraph
            conso(eo, restHyperedges, newHypergraph),
            proveso(newHypergraph, filteredBicliques, restSteps)])))

const lessThan3o = Rel((hyperedge) =>
    exist((n) => [
        conde(
            eq(n, ['z']),
            eq(n, ['s', 'z']),
            eq(n, ['s', 's', 'z'])),
            
        sizeo(hyperedge, n)]))
            
const anyLessThan3o = Rel((hypergraph) =>
    exist((hyperedge, restHyperedges) => [
        conso(hyperedge, restHyperedges, hypergraph),
        conde(
            lessThan3o(hyperedge),
            anyLessThan3o(restHyperedges))]))

const sizeo = Rel((hyperedge, size) =>
    conde(
        [nilo(hyperedge), eq(size, ['z'])],
        exist((first, rest, sizeRec) => [
            conso(first, rest, hyperedge),
            conde(
                [eq(first, 0), eq(size, sizeRec)],
                [eq(first, 1), conso('s', sizeRec, size)],
            ),
            sizeo(rest, sizeRec)])))
            
            
const filterBicliqueso = Rel((x, l, o) =>
    conde(
        [nilo(l), nilo(o)],
        exist((carL, cdrL, oRest) => [
            conso(carL, cdrL, l),
            conde(
                [conso(carL, oRest, o),
                    allDisjointo(x, carL)],
                [eq(o, oRest),
                    anyOverlapo(x, carL)]),
            filterBicliqueso(x, cdrL, oRest)])))
            
const overlapo = Rel((u, v) =>
    exist((x) => [
        eq(x, [u, v]),
        conde(
            eq(x, ['l', 'l']),
            eq(x, ['l', 'r']),
            eq(x, ['r', 'l']),
            eq(x, ['r', 'r']))]))
            
const anyOverlapo = Rel((x, y) =>
    exist((carX, cdrX, carY, cdrY) => [
        conso(carX, cdrX, x),
        conso(carY, cdrY, y),
        conde(
            overlapo(carX, carY),
            anyOverlapo(cdrX, cdrY))]))
            
const disjointo = Rel((u, v) =>
    conde(
        eq(u, 'o'),
        eq(v, 'o')))
        
const allDisjointo = Rel((x, y) =>
    conde(
        [nilo(x), nilo(y)],
        exist((carX, cdrX, carY, cdrY) => [
            conso(carX, cdrX, x),
            conso(carY, cdrY, y),
            disjointo(carX, carY),
            allDisjointo(cdrX, cdrY)])))
            

const abcHypergraph = [
    [1, 0, 1, 1, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 1, 1]]
    
const abcBicliques = [
    ['l', 'r', 'o', 'o', 'o', 'o', 'o', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'o', 'l', 'r', 'o', 'o'],
    // ...
    ['o', 'o', 'l', 'l', 'l', 'l', 'r', 'o', 'o']]


const k4Hypergraph = [
    [1, 1, 1, 0],
    [0, 1, 1, 1]]
    
const k4Bicliques = [
    ['l', 'o', 'o', 'r']]

---

@s A translation of the proves relation to Python and Typescript

Imports

--- main.py
from dataclasses import dataclass
from typing import List, Optional, Tuple, Set, TypeVar, Dict

T = TypeVar('T')
---

--- main.ts

---

--- main.c
#include <stdlib.h>
#include <stdbool.h>

int main() {
	return 0;
}
---

Type declarations

--- main.py +=
Biclique = List[str] # List[Literal['l', 'r', 'o']]
Hyperedge = List[str] # List[Literal['x', 'o']]
ProofStep = List[str] # List[Literal['a', 'b', 'u', 'v', 'w', 'o']]
Hypergraph = List[Hyperedge]
---

--- main.ts +=
type Biclique = Array<('l' | 'r' | 'o')>
type Hyperedge = Array<('x' | 'o')>
type ProofStep = Array<('a' | 'b' | 'u' | 'v' | 'w' | 'o')>
type Hypergraph = Array<Hyperedge>
---

--- main.c +=
typedef char *Biclique; // 'l', 'r', 'o'
typedef char *Hyperedge; // 'x', 'o'
typedef char *ProofStep; // 'a', 'b', 'u', 'v', 'w', 'o'
typedef Hyperedge *Hypergraph;
---

Adapted from StackOverflow: https://stackoverflow.com/a/40834276

--- main.py +=
def odd_paths(graph: List[List[int]], start: int, end: int) -> List[List[int]]:
	paths = []
	fringe = [(start, [])]

	while len(fringe) > 0:
		vertex, path = fringe.pop()
		if (len(path) % 2) == 1 and vertex == end:
			paths.append(path)
			continue

		for neighbor in graph[vertex]:
			if neighbor not in path:
				fringe.append((neighbor, path + [neighbor]))

	return paths
	
def odd_cycles(num_vertices: int, graph: List[List[int]]) -> Hypergraph:
	result: Hypergraph = []
	seen: Set[str] = set()

	for vertex in graph:
		for	odd_cycle in odd_paths(graph, vertex, vertex):
			hyperedge: Hyperedge = ['o'] * num_vertices
			
			for v in odd_cycle:
				hyperedge[v] = 'x'
				
			hyperedge_str = ''.join(hyperedge)
			if hyperedge_str not in seen:
				seen.add(hyperedge_str)
				result.append(hyperedge)

	return result
---

--- main.py +=
def all_bicliques(graph: List[List[bool]]) -> List[Biclique]:
	num_vertices = len(graph)
	result = []
	ls_and_os_and_rs = unriffle([x for x in range(num_vertices)])
	
	for ls_and_os, rs in unriffle([x for x in range(num_vertices)]):
		for ls, os, in unriffle(ls_and_os):
			if (
				len(ls) != 0 and
				len(rs) != 0 and
				is_biclique(l, r, graph)
			):
				biclique = ['o'] * num_vertices
				
				for l in ls:
					biclique[l] = 'l'
				
				for r in rs:
					biclique[r] = 'r'
				
				result.append(biclique)
	
	return result
---

--- main.py +=
def any_overlap(a: Biclique, b: Biclique) -> bool:
	num_vertices = len(a[0])
    
	for v in range(num_vertices):
		if (
			(a[v] == 'l' and b[v] == 'l') or
			(a[v] == 'l' and b[v] == 'r') or
			(a[v] == 'r' and b[v] == 'l') or
			(a[v] == 'r' and b[v] == 'r')
		):
			return True

	return False
---

--- main.ts +=
function anyOverlap(a: Biclique, b: Biclique): boolean {
    const numVertices = a[0].length;
    
    for (let v = 0; v < numVertices; v++) {
		if (
			(a[v] === 'l' && b[v] === 'l') ||
			(a[v] === 'l' && b[v] === 'r') ||
			(a[v] === 'r' && b[v] === 'l') ||
			(a[v] === 'r' && b[v] === 'r')
		) {
			return true;
		}
    }
    
    return false;
}
---

--- main.c +=
static bool any_overlap(Biclique a, Biclique b, int num_vertices) {
	for (int v = 0; v < num_vertices; v++) {
		if (
			(a[v] == 'l' && b[v] == 'l') ||
			(a[v] == 'l' && b[v] == 'r') ||
			(a[v] == 'r' && b[v] == 'l') ||
			(a[v] == 'r' && b[v] == 'r')
		) {
			return true;
		}
	}
	
	return false;
}
---

--- main.py +=
def any_edge_has_less_than_three(h: Hypergraph) -> bool:
    for hyperedge in h:
        edge_size = 0
        for vertex in hyperedge:
            if vertex == 'x':
                edge_size += 1

        if edge_size < 3:
            return True
            
    return False
---

--- main.ts +=
function anyEdgeHasLessThanThree(h: Hypergraph): boolean {
    for (let hyperedge of h) {
        let edgeSize = 0;
        for (let vertex of hyperedge) {
            if (vertex === 'x') {
                edgeSize += 1;
            }
        }
        
        if (edgeSize < 3) {
            return true;
        }
    }
    
    return false;
}
---

--- main.c +=
static bool any_edge_has_less_than_three(Hypergraph h, int num_hyperedges, int num_vertices) {
	for (int i = 0; i < num_hyperedges; i++) {
		Hyperedge hyperedge = h[i];
		int edge_size = 0;
		for (int j = 0; j < num_vertices; j++) {
			char vertex = hyperedge[j];
			if (vertex == 'x') {
				edge_size += 1;
			}
		}

		if (edge_size < 3) {
			return true;
		}
	}
	
	return false;
}
---

--- main.py +=
def attempt_proof_step(
    a: Hyperedge,
    b: Hyperedge,
    biclique: Biclique
) -> Optional[Tuple[ProofStep, Hyperedge]]:

    num_vertices = len(a)
    proof_step: ProofStep = []
    new_h: Hyperedge = []
    
    for v in range(num_vertices):
        x = a[v] + b[v] + biclique[v]

        if x == 'xol':
            proof_step.append('a')
            new_h.append('o')

        elif x == 'oxr':
            proof_step.append('b')
            new_h.append('o')
                
        elif x == 'xoo':
            proof_step.append('u')
            new_h.append('x')
                
        elif x == 'oxo':
            proof_step.append('v')
            new_h.append('x')
                
        elif x == 'xxo':
            proof_step.append('w')
            new_h.append('x')
                
        elif x == 'ooo':
            proof_step.append('o')
            new_h.append('o')
                
        else:
            return None
            
    return (proof_step, new_h)
---

--- main.ts +=
function attemptProofStep(
    a: Hyperedge,
    b: Hyperedge,
    biclique: Biclique
): [ProofStep, Hyperedge] | null {
    
    const numVertices = a.length;
    let proofStep: ProofStep = [];
    let newH: Hyperedge = [];
    
    for (let v = 0; v < numVertices; v++) {
        const x = a[v] + b[v] + biclique[v];
    
        if (x === 'xol') {
            proofStep.push('a');
            newH.push('o');

        } else if (x === 'oxr') {
            proofStep.push('b');
            newH.push('o');

        } else if (x === 'xoo') {
            proofStep.push('u');
            newH.push('x');
        
        } else if (x === 'oxo') {
            proofStep.push('v');
            newH.push('x');
        
        } else if (x === 'xxo') {
            proofStep.push('w');
            newH.push('x');
        
        } else if (x === 'ooo') {
            proofStep.push('o');
            newH.push('o');
        
        } else {
            return null;
        }
    }
    
    return [proofStep, newH];
}

---

--- main.c +=
static bool attempt_proof_step(Hyperedge a, Hyperedge b, Biclique q, int num_vertices, ProofStep proof_step, Hyperedge new_h) {
	for (int v = 0; v < num_vertices; v++) {
		if (a[v] == 'x' && b[v] == 'o' && q[v] == 'l') {
			proof_step[v] = 'a';
			new_h[v] = 'o';

		} else if (a[v] == 'o' && b[v] == 'x' && q[v] == 'r') {
			proof_step[v] = 'b';
			new_h[v] = 'o';

		} else if (a[v] == 'x' && b[v] == 'o' && q[v] == 'o') {
			proof_step[v] = 'u';
			new_h[v] = 'x';
			
		} else if (a[v] == 'o' && b[v] == 'x' && q[v] == 'o') {
			proof_step[v] = 'v';
			new_h[v] = 'x';
		
		} else if (a[v] == 'x' && b[v] == 'x' && q[v] == 'o') {
			proof_step[v] = 'w';
			new_h[v] = 'x';
		
		} else if (a[v] == 'o' && b[v] == 'o' && q[v] == 'o') {
			proof_step[v] = 'o';
			new_h[v] = 'o';
		
		} else {
			return false;
		}
	}

	return true;
}
---

--- main.py +=
def remove2add1(h: Hypergraph, i: int, j: int, new_h: Hyperedge) -> Hypergraph:
    result = []
    
    for index in range(len(h)):
        if index != i and index != j:
            result.append(h[index])
            
    result.append(new_h)
    return result
---

--- main.ts +=
function remove2add1(h: Hypergraph, i: number, j: number, newH: Hyperedge): Hypergraph {
    let result: Hypergraph = [];
    
    for (let index = 0; index < h.length; index++) {
        if (index !== i && index !== j) {
            result.push(h[index]);
        }
    }
    
    result.push(newH);
    return result;
}
---

--- main.c +=
static void remove2add1(Hypergraph h, int i, int j, int num_hyperedges, Hyperedge new_h, Hypergraph out) {
	int l = 0;
	for (int index = 0; index < num_hyperedges; index++) {
		if (index != i && index != j) {
			out[l] = h[index];
			l++;
		}
	}
	
	out[l] = new_h;
}
---

Venn diagram relationship

--- main.py +=
def venn_diagram(a: Hyperedge, b: Hyperedge) -> Tuple[List[int], List[int], List[int], List[int]]:
	left, right, both, neither = [], [], [], []
	
	num_vertices = len(a)
	
	for i in range(num_vertices):
		if a[i] == 'x' and b[i] == 'o':
			left.append(i)
			
		if a[i] == 'o' and b[i] == 'x':
			right.append(i)
	
		if a[i] == 'x' and b[i] == 'x':
			both.append(i)
			
		if a[i] == 'o' and b[i] == 'o':
			neither.append(i)
			
	return left, right, both, neither
---

--- main.ts +=
function venn_diagram(a: Hyperedge, b: Hyperedge): [Array<number>, Array<number>, Array<number>, Array<number>] {
	let [left, right, both, neither] = [[], [], [], []];
	
	const numVertices = a.length;
	
	for (let i = 0; i < numVertices; i++) {
		if (a[i] === 'x' && b[i] === 'o') {
			left.push(i);
		}
	
		if (a[i] === 'o' && b[i] === 'x') {
			right.push(i);
		}
		
		if (a[i] === 'x' && b[i] === 'x') {
			both.push(i);
		}
		
		if (a[i] === 'o' && b[i] === 'o') {
			neither.push(i);
		}
	}

	return [left, right, both, neither];
}
---

--- main.py +=
def is_biclique(us: List[int], vs: List[int], graph: List[List[bool]]) -> bool:
	for u in us:
		for v in vs:
			if not graph[u][v]:
				return False
			
	return True
---

--- main.py +=
def proves(h: Hypergraph, graph: List[List[bool]]) -> Optional[List[ProofStep]]:
	num_vertices = len(h[0])

	if any_edge_has_less_than_three(h):
		return []

	# Any biclique between two hyperedges leads to a new proveable hypergraph
	for i in range(len(h)):
		for j in range(len(h)):
			if i != j:
				left, right, both, neither = venn_diagram(h[i], h[j])

				ls = unriffle(left)
				rs = unriffle(right)

				for l, _ in ls:
					for r, _ in rs:
						if (
							len(l) != 0 and
							len(r) != 0 and
							is_biclique(l, r, graph)
						):
							nonoverlapping = [x
								for x in h
								if disjoint(x, h[i]) and disjoint(x, h[j])
							]
							
							
							# new_hyperedge = (h[i] \/ h[j]) - (l \/ r)
							new_hyperedge = union(h[i], h[j])

							for v in l:
								new_hyperedge[v] = 'o'
							
							for v in r:
								new_hyperedge[v] = 'o'
								
							new_graph = [[False] * num_vertices] * num_vertices
							
							for i in range(num_vertices):
								for j in range(num_vertices):
									if i in l or i in r or j in l or j in r:
										new_graph[i][j] = False
									else:
										new_graph[i][j] = graph[i][j]

							if proves(remove2add1(h, i, j, new_hyperedge) + new_hyperedge, new_graph):
								return True
	return False
---

--- main.ts +=
function proves(h: Hypergraph, bicliques: Array<Biclique>): (Array<ProofStep> | null) {
    if (anyEdgeHasLessThanThree(h)) {
        return [];
    }

    for (let i = 0; i < h.length; i++) {
        for (let j = 0; j < h.length; j++) {
            for (let biclique of bicliques) {
                if (i !== j) {
                    const attempt = attemptProofStep(h[i], h[j], biclique);
                    
                    if (attempt !== null) {
                        const [proofStep, newHyperedge] = attempt;
                        
                        const proofSteps = proves(
                            remove2add1(h, i, j, newHyperedge),
                            bicliques.filter(x => !anyOverlap(x, biclique))
                        );
                        
                        if (proofSteps !== null) {
                            return proofSteps.concat([proofStep]);
                        }
                    }
                }
            }
        }
    }
    
    return null;
}
---

--- main.c +=
static bool proves(Hypergraph h, Biclique *bicliques, int num_hyperedges, int num_vertices, int num_bicliques, ProofStep *out) {
	if (any_edge_has_less_than_three(h, num_hyperedges, num_vertices)) {
		return true;
	}
	
	Hyperedge new_h = malloc(num_vertices * sizeof(char));
	ProofStep proof_step = malloc(num_vertices * sizeof(char));
	Hypergraph new_hypergraph = malloc(num_hyperedges * sizeof(Hyperedge));
	
	for (int i = 0; i < num_hyperedges; i++) {
		for (int j = 0; j < num_hyperedges; j++) {
			for (int k = 0; k < num_bicliques; k++) {
				if (i != j) {
					bool attempt = attempt_proof_step(h[i], h[j], bicliques[k], num_vertices, proof_step, new_h);
	
					if (attempt) {
						remove2add1(h, i, j, num_hyperedges, new_h, new_hypergraph);
						
						
					
					}
				}
			}
		}
	}
	
	free(new_h);
	free(proof_step);
	free(new_hypergraph);
	
	return false;
}
---

@s Unique int sets

--- main.py +=
def unique(x: List[List[bool]]) -> List[List[bool]]:
	found = set()
	result = []
	
	for bool_list in x:
		representation = ''.join(['1' if bit else '0' for bit in bool_list])
		if representation not in found:
			found.add(representation)
			result.append(bool_list)
			
	return result
---

@s Parsing the graph6 format

Adapted from [http://users.cecs.anu.edu.au/~bdm/data/formats.txt](http://users.cecs.anu.edu.au/~bdm/data/formats.txt).

--- main.py +=
def decode(g6: str) -> Tuple[List[List[int]], int]:
	def as_int(char):
		return ord(char) - 63

	num_vertices = as_int(g6[0])
	
	bits = [
		x == '1'
		for c in g6[1:]
		for x in format(as_int(c), '6b')
	]

	graph = {x: [] for x in range(num_vertices)}

	index = 0
	for i in range(num_vertices):
		for j in range(i):
			if bits[index]:
				graph[i].append(j)
				graph[j].append(i)
			
			index += 1
			
	return graph, num_vertices
---

@s Extracting the Sperner family
We only need to deal with the smallest subsets, so we can create Sperner families. I do not know an efficient way to do this other than by pairwise enumeration.

The algorithm only works if the hypergraph is simple, that is, there are no repeated edges. Otherwise two equal hyperedges would be subsets of each other and neither would be included.

--- main.py +=
def sperner_family(hypergraph: Hypergraph) -> Hypergraph:
    result = []
    for i in range(len(hypergraph)):
        any_subset = False
        for j in range(len(hypergraph)):
            if i != j and is_subset(hypergraph[j], hypergraph[i]):
                any_subset = True
                break

        if not any_subset:
            result.append(hypergraph[i])
            
    return result
---

--- main.ts +=
function spernerFamily(hypergraph: Hypergraph): Hypergraph {
    let result: Hypergraph = [];
    for (let i = 0; i < hypergraph.length; i++) {
        let anySubset = false;
        for (let j = 0; j < hypergraph.length; j++) {
            if (i !== j && isSubset(hypergraph[j], hypergraph[i])) {
                anySubset = true;
                break;
            }
        }

        if (!anySubset) {
            result.push(hypergraph[i]);
        }
    }

    return result;
}
---

--- main.py +=
def is_subset(subset: Hyperedge, superset: Hyperedge) -> bool:
    num_vertices = len(subset)
    
    for i in range(num_vertices):
        if subset[i] == 'x' and superset[i] == 'o':
            return False
            
    return True
    
def disjoint(a: Hyperedge, b: Hyperedge) -> bool:
	num_vertices = len(a)
	
	for i in range(num_vertices):
		if a[i] == 'x' and b[i] == 'x':
			return False
			
	return True
	
def union(a: Hyperedge, b: Hyperedge) -> bool:
	num_vertices = len(a)
	
	result = []
	for i in range(num_vertices):
		if a[i] == 'x' or b[i] == 'x':
			result.append('x')
		else:
			result.append('o')
			
	return result
---


--- main.ts +=
function isSubset(subset: Hyperedge, superset: Hyperedge): boolean {
    const numVertices = subset.length;

    for (let i = 0; i < numVertices; i++) {
        if (subset[i] === 'x' && superset[i] === 'o') {
            return false;
        }
    }
    
    return true;
}

function hyperedgeOverlap(a: Hyperedge, b: Hyperedge): bool {
	let numVertices = a.length;
	
	for (let i = 0; i < numVertices; i++) {
		if (a[i] === 'x' && b[i] === 'x') {
			return true;
		}
	}
	
	return false;
}
---

--- main.py +=
k4_hypergraph: Hypergraph = [
    ['x', 'x', 'x', 'o'],
    ['o', 'x', 'x', 'x']]
    
k4_bicliques: List[Biclique] = [
    ['l', 'o', 'o', 'r']]


abc_hypergraph: Hypergraph = [
    ['x', 'o', 'x', 'x', 'o', 'o', 'o', 'o', 'o'],
    ['o', 'x', 'o', 'o', 'x', 'x', 'o', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'o', 'o', 'x', 'x', 'x']]
    
abc_bicliques: List[Biclique] = [
    ['l', 'r', 'o', 'o', 'o', 'o', 'o', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'l', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'o', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'l', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'o', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'o', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'o', 'l', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'o', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'l', 'l', 'r', 'o', 'o']]
---

--- main.ts +=
const k4Hypergraph: Hypergraph = [
    ['x', 'x', 'x', 'o'],
    ['o', 'x', 'x', 'x']]
    
const k4Bicliques: Array<Biclique> = [
    ['l', 'o', 'o', 'r']]

const abcHypergraph: Hypergraph = [
    ['x', 'o', 'x', 'x', 'o', 'o', 'o', 'o', 'o'],
    ['o', 'x', 'o', 'o', 'x', 'x', 'o', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'o', 'o', 'x', 'x', 'x']]
    
const abcBicliques: Array<Biclique> = [
    ['l', 'r', 'o', 'o', 'o', 'o', 'o', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'o', 'l', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'o', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'o', 'l', 'l', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'o', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'o', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'o', 'l', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'o', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'o', 'l', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'l', 'o', 'r', 'o', 'o'],
    ['o', 'o', 'l', 'l', 'l', 'l', 'r', 'o', 'o']]
---

@s Running on examples

--- main.py +=
def to_adjacency_matrix(num_vertices: int, int_graph: Dict[int, List[int]]) -> List[List[bool]]:
	result = []

	for vertex in int_graph:
		adj_list = [False] * num_vertices
		for neighbor in int_graph[vertex]:
			adj_list[neighbor] = True
		
		result.append(adj_list)
		
	return result
			

def run(graph6: str) -> bool:
	int_graph, num_vertices = decode(graph6)
	
	h = sperner_family(odd_cycles(num_vertices, int_graph))

	graph = to_adjacency_matrix(num_vertices, int_graph)
	
	bicliques = all_bicliques(graph)

	return proves(h, bicliques)




print(run('JHO\MageEG?')) # Grotzsch graph
---

@s Non-3-colorability and odd cycles
Proving a graph $G$ is not 3-colorable involves operations on the odd cycles contained in the graph. Therefore it would be useful to collect a set of sets of vertices, where the outer set contains the inner set if and only if there is an odd cycle in $G$ containing exactly those vertices in the inner set.

A hypergraph would be the most appropriate data structure for representing this set-of-sets since the innermost elements are vertices corresponding to vertices of the original graph $G$. Let's call this an **odd cycle hypergraph** $H$ that can be generated from $G$.

![test](../diagrams/odd-cycle-hypergraph.jpg "an odd cycle hypergraph")

For example, consider the above graph $G$, its 4 odd cycles, and its *odd cycle hypergraph*, $H$, which contains 4 hyperedges. It has 4 odd cycles drawn shown separately. Since two of the hyperedges have the exact same vertices, the hypergraph is [non-simple](https://en.wikipedia.org/wiki/Hypergraph#Properties_of_hypergraphs).


An efficient representation of a hypergraph is to use a two-dimensional boolean array where the rows are hyperedges and the columns are vertices. Each cell  $(e, v)$ holds the value `true` if vertex $v$ is included in the hyper-edge $e$, and `false` otherwise.

@ Results that would disprove this non-3-colorability deduction system

1. Is there a 4-critical graph (achieved by the Hajos construction) that does not have a proof string? That is, is this deduction system sound, but incomplete?

2. Is there a 4-critical graph that requires a hyperedge to be used twice?

3. Is there a 4-critical graph that requires a biclique to be used twice? That is, is the rearrangement lemma false?
