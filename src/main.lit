@title Short proofs of graph non-3-colorability

@s Introduction

This is just a sample introduction to see how the Literate tool works.


--- brett.ts

function helloWorld() {
    console.log('Hello, world 3!');
}

---


@s A few attempts at analogies

**The Student Prankster Problem**
- Imagine you have a university where many students take many classes. A student can be in many classes, and many students can be in one class.
- There are certain rivalries between classes. Some sets of students will go bother other students 



@s The Student Prankster problem

Algorithm:

1. Pick a war and its combatants.
2. Fight through all outcomes.
3. Mark any wars which are now viable or unviable.
4. Recurse.
5. If no solution found, "undo" your last war and pick another. Unmark the viable and unviable wars.

This algorithm only works if there does not exist a sequence of wars which is ambiguous.


A sequence of wars is unambiguous. But it leads to a combinatorial explosion. That means searching for the next wars is easy -- just pick one. But to *verify* a sequence of wars, you ought to have the combatants handy for each war so that it's easy to keep track.

@s A nondeterministic miniKanren algorithm: Verifying that a certain sequence of wars produces a hypergraph of size < 3

--- main.mk.scm
(load "~/miniKanren/mk.scm")

@{The riffle relation}
---

@s
Now we must verify that there is indeed a conflict between $h_1$ and $h_2$. So we must go through $G$ to verify that it contains every edge $(u, v)$ (or $(v, u)$).

- There is a complete bipartite subgraph such that
    - the first half is in h1 and not in h2
    - the second half is in h2 and not in h1
- h3 is the union of the vertices in h1 and h2 that are not in the cbs

Consider 6 disjoint sets:

TODO: Replace the 1 and 2s in the below definition with ls and rs.
In fact, we may not even need this symbol convention since it is entirely covered


<table>
    <tr>
        <th>Name</th><th>Stands for</th><th>Description</th>
    </tr>
    <tr>
        <td>$r_1$</td>
        <td>Rivals 1</td>
        <td>The partition of the CBS contained in $h_1$ </td>
    </tr>
    <tr>
        <td>$r_2$</td>
        <td>Rivals 2</td>
        <td>The partition of the CBS contained in $h_2$ </td>
    </tr>
    <tr>
        <td>$b_1$</td>
        <td>Bystanders 1</td>
        <td>The vertices contained in $h_1$ but not $h_2$, and not in the CBS.</td>
    </tr>
    <tr>
        <td>$b_2$</td>
        <td>Bystanders 2</td>
        <td>The vertices contained in $h_2$ but not $h_1$, and not in the CBS.</td>
    </tr>
    <tr>
        <td>$b$</td>
        <td>Bystanders (both)</td>
        <td>The vertices contained in both $h_1$ and $h_2$, but not in the CBS.</td>
    </tr>
    <tr>
        <td>$o$</td>
        <td>Outsiders</td>
        <td>The vertices not contained in either $h_1$ or $h_2$.</td>
    </tr>
</table>

![test](../diagrams/h1-h2-relationship.jpg "The relationship between h1 and h2")

The above definition, in a relationship with $h_1$ and $h_2$. This is how proof steps are encoded.

--- main.mk.scm +=

(define proof-stepo (lambda (step h-l h-r cbs h-out)
    (conde
        ((== step '()) (== h-l '()) (== h-r '()) (== cbs '()) (== h-out '()))
        ((fresh (car-h-l cdr-h-l car-h-r cdr-h-r car-h-out cdr-h-out car-step cdr-step car-cbs cdr-cbs)
            (== step `(,car-step . ,cdr-step))
            (== h-l `(,car-h-l . ,cdr-h-l))
            (== h-r `(,car-h-r . ,cdr-h-r))
            (== cbs `(,car-cbs . ,cdr-cbs))
            (== h-out `(,car-h-out . ,cdr-h-out))
            (conde
                ((== car-h-l 0) (== car-h-r 0) (== car-h-out 0) (== car-cbs 'o) (== car-step 'o))
                ((== car-h-l 1) (== car-h-r 0) (== car-h-out 0) (== car-cbs 'l) (== car-step 'r1))
                ((== car-h-l 1) (== car-h-r 0) (== car-h-out 1) (== car-cbs 'o) (== car-step 'b1))
                ((== car-h-l 0) (== car-h-r 1) (== car-h-out 0) (== car-cbs 'r) (== car-step 'r2))
                ((== car-h-l 0) (== car-h-r 1) (== car-h-out 1) (== car-cbs 'o) (== car-step 'b2))
                ((== car-h-l 1) (== car-h-r 1) (== car-h-out 1) (== car-cbs 'o) (== car-step 'b)))
            (proof-stepo cdr-step cdr-h-l cdr-h-r cdr-cbs cdr-h-out))))))
---

There is a crucial detail missing in the proof step. And that is that $R_1$ and $R_2$ must be nonempty. Therefore it is trusted that the caller passes in cbs with a nonempty **left** and nonempty **right** side.

--- main.mk.scm +=
(define proveso (lambda (h cbs steps)
    (conde
        ((== steps '()) (any-less-than-3o h))
        ((fresh (step rest-steps h1 h2 h-l h-r h-out h-rest c rest-cbs new-cbs)
            (== steps `(,step . ,rest-steps))
            ;; Pick two hyperedges
            (riffleo `(,h1 ,h2) h-rest h)
            
            ;; Order matters since one will be considered "left" and the other "right"
            (riffleo `(,h-l) `(,h-r) `(,h1 ,h2))
            
            ;; Pick one cbs
            (riffleo `(,c) rest-cbs cbs)

            ;; These hyperedges must be connected
            (proof-stepo step h-l h-r c h-out)
            
            (filter-cbso c rest-cbs new-cbs)
            
            ;; Recur on the rest of the steps with the newly-made h-out
            (proveso `(,h-out . ,h-rest) new-cbs rest-steps))))))

(define any-less-than-3o (lambda (h)
    (fresh (car-h cdr-h)
        (== h `(,car-h . ,cdr-h))
        (conde
            ((less-than-3o car-h))
            ((any-less-than-3o cdr-h))))))

(define less-than-3o (lambda (hyperedge)
    (fresh (n)
        (conde
            ((== n 'z))
            ((== n `(s . z)))
            ((== n `(s s . z))))
            
        (sizeo hyperedge n))))
     
@{Sizeo}
---

@s Definition of a complete bipartite subgraph
A complete bipartite subgraph in a graph with $n$ vertices can be represented as a list of length $n$, where each element is one of the following.

$l$
: Belongs to the **left** side of the complete bipartite subgraph.

$r$
: Belongs to the **right** side of the complete bipartite subgraph.

$o$
: Not included in the complete bipartite subgraph.

@s Discarding CBSes with used vertices

--- main.mk.scm +=
(define ex-a '(l o r o l))
(define ex-l '(
    (l o o r o)
    (r o l o o)
    (o l o r o)
    (o r r l o)))

(define filter-cbso (lambda (x l o)
    (conde
        ((== l '()) (== o '()))
        ((fresh (car-l cdr-l should-discard o-rest)
            (== l `(,car-l . ,cdr-l))
            (conde
                ((== should-discard #f) (== o `(,car-l . ,o-rest)))
                ((== should-discard #t) (== o o-rest)))
            (overlapso x car-l should-discard)
            (filter-cbso x cdr-l o-rest))))))

(define overlapso (lambda (x y result)
    (conde
        ((== x '()) (== y '()) (== result #f))
        ((fresh (car-x cdr-x car-y cdr-y)
            (== x `(,car-x . ,cdr-x))
            (== y `(,car-y . ,cdr-y))
            (conde
                (
                    (== result #t)
                    (conde
                        ((== car-x 'l) (== car-y 'l))
                        ((== car-x 'r) (== car-y 'l))
                        ((== car-x 'l) (== car-y 'r))
                        ((== car-x 'r) (== car-y 'r))))
                (
                    (conde
                        ((== car-x 'o))
                        ((== car-y 'o)))
                        
                    (overlapso cdr-x cdr-y result))))))))
---


@s The size of a hyperedge
Since a hypergraph is a 0-1 matrix whose columns are vertices and whose rows are edges which contain those vertices, then the size of a hyperedge (represented as a list) is the number of 1s in it.


--- Sizeo
(define sizeo (lambda (hyperedge size)
    (fresh (rest)
        (conde
            ((== hyperedge '()) (== size 'z))
            ((== hyperedge `(0 . ,rest)) (sizeo rest size))
            ((== hyperedge `(1 . ,rest)) (sizeo rest `(s . ,size)))))))
---

Applying Will's law

--- Sizeo :=
(define sizeo (lambda (hyperedge size)
    (fresh (first rest size-rec)
        (conde
            ((== hyperedge '()) (== size 'z))
            ((== hyperedge `(,first . ,rest))
                (conde
                    ((== first 0) (== size size-rec))
                    ((== first 1) (== size `(s . ,size-rec))))
                (sizeo rest size-rec))))))
---

@s Sample graph-hypergraphs to test on

![Sample graph and hypergraph](../diagrams/sample-graph-and-hypergraph.jpg "A sample graph and hypergraph")

--- main.mk.scm +=
(define sample-hypergraph '(
    (1 1 1 0 0 0 0 0 0)
    (0 0 0 1 1 1 0 0 0)
    (0 0 0 0 0 0 1 1 1)))
    
(define sample-graph '(
    (0 0 0 1 0 0 0 0 0)
    (0 0 0 0 0 0 1 0 0)
    (0 0 0 0 0 0 1 0 0)
    (1 0 0 0 0 0 0 0 0)
    (0 0 0 0 0 0 1 0 0)
    (0 0 0 0 0 0 1 0 0)
    (0 1 1 0 1 1 0 0 0)
    (0 0 0 0 0 0 0 0 0)
    (0 0 0 0 0 0 0 0 0)))
---

I had to draw this smaller hypergraph because the above was taking longer than 5 minutes. I just want to see if $proves^o$ even works.

![Smaller sample graph and hypergraph](../diagrams/smaller-sample-graph-and-hypergraph.jpg "A smaller sample graph and hypergraph")

--- main.mk.scm +=
(define smaller-sample-hypergraph '(
    (1 1 1 0)
    (0 1 1 1)))

(define smaller-sample-graph '(
    (0 0 0 1)
    (0 0 0 0)
    (0 0 0 0)
    (1 0 0 0)))
---

@ABC Example

![ABC example](../diagrams/abc-example.jpg "ABC example")

--- main.mk.scm +=
(define abc-example-hypergraph '(
    (1 0 1 1 0 0 0 0 0)
    (0 1 0 0 1 1 0 0 0)
    (0 0 0 0 0 0 1 1 1)))

(define abc-example-cbh '(
    (l r o o o o o o o)
    (o o o o o l r o o)
    (o o o o l o r o o)
    (o o o o l l r o o)
    (o o o l o o r o o)
    (o o o l o l r o o)
    ;; (o o o l l o r o o) ;; This edge seems to add 8s to the search
    (o o l l l l r o o)))
---

@K4 Example

The simplest example, the base case $K_4$.

--- main.mk.scm +=
(define k4-example-hypergraph '(
    (1 1 1 0)
    (0 1 1 1)))
    
(define k4-example-cbh '(
    (l o o r)))
---

Testing filter-cbso

--- main.mk.scm +=
(define example-cbs
    '(l l l l l l l l l l l l l l o o o))

(define example-filter '(
 (o o o o o o o o o o o o r o o o l)
 (o o o o o o o o o o o l o o o o l)
 (o o o o o o o o o o o r o o o o l)
 (o o o o o o o o o o l o o o o o l)
 (o o o o o o o o o o r o o o o o l)
 (o o o o o o o o o l o o o o o o l)
 (o o o o o o o o o r o o o o o o l)
 (o o o o o o o o l o o o o o o o l)
 (o o o o o o o o r o o o o o o o l)
 (o o o o o o o l o o o o o o o o l)
 (o o o o o o o r o o o o o o o o l)
 (o o o o o o l o o o o o o o o o l)
 (o o o o o o r o o o o o o o o o l)
 (o o o o o l o o o o o o o o o o l)
 (o o o o o r o o o o o o o o o o l)
 (o o o o l o o o o o o o o o o o l)
 (o o o o r o o o o o o o o o o o l)
 (o o o l o o o o o o o o o o o o l)
 (o o o r o o o o o o o o o o o o l)
 (o o l o o o o o o o o o o o o o l)
 (o o r o o o o o o o o o o o o o l)
 (o l o o o o o o o o o o o o o o l)
 (o r o o o o o o o o o o o o o o l)
 (l o o o o o o o o o o o o o o o l)
 (r o o o o o o o o o o o o o o o l)
 (o o o o o o o o o o o o o o r o r)
 (o o o o o o o o o o o o o o l l o)
 (o o o o o o o o o o o o o l o o r)
 (o o o o o o o o o o o o o o r l o)
 (o o o o o o o o o o o o o r o o r)
 (o o o o o o o o o o o o l o o o r)
 (o o o o o o o o o o o o r o o o r)
 (o o o o o o o o o o o l o o o o r)
 (o o o o o o o o o o o r o o o o r)
 (o o o o o o o o o o l o o o o o r)
 (o o o o o o o o o o r o o o o o r)
 (o o o o o o o o o l o o o o o o r)
 (o o o o o o o o o r o o o o o o r)
 (o o o o o o o o l o o o o o o o r)
 (o o o o o o o o r o o o o o o o r)
 (o o o o o o o l o o o o o o o o r)
 (o o o o o o o r o o o o o o o o r)
 (o o o o o o l o o o o o o o o o r)
 (o o o o o o r o o o o o o o o o r)
 (o o o o o l o o o o o o o o o o r)
 (o o o o o r o o o o o o o o o o r)
 (o o o o l o o o o o o o o o o o r)
 (o o o o r o o o o o o o o o o o r)
 (o o o l o o o o o o o o o o o o r)
 (o o o r o o o o o o o o o o o o r)
 (o o l o o o o o o o o o o o o o r)
 (o o r o o o o o o o o o o o o o r)
 (o l o o o o o o o o o o o o o o r)
 (o r o o o o o o o o o o o o o o r)
 (l o o o o o o o o o o o o o o o r)))

    
(define is-cbs (lambda (l)
    (conde
        ((== l '()))
        ((fresh (car-l cdr-l)
            (== l `(,car-l . ,cdr-l))
            (conde
                ((== car-l 'o))
                ((== car-l 'l))
                ((== car-l 'r)))
            (is-cbs cdr-l))))))
---

@s Appendix A: The Riffle Relation

Adapted from [here](https://github.com/schreiberbrett/cool-relations/blob/main/the-riffle-relation.md).

--- The riffle relation
(define riffleo (lambda (a b o)
    (fresh (car-a cdr-a car-b cdr-b car-o cdr-o z0 z1)
        (conde
            ;; If `a` and `b` are both empty, then the output is empty.
            ((== a '()) (== b '()) (== o '()))
            
            ;; If `a` is non-empty and `b` is empty, then the output is equal to `a`.
            ((== a `(,car-a . ,cdr-a)) (== b '()) (== o a))
            
            ;; If `a` is empty and `b` is non-empty, then the output is equal to `b`.
            ((== a '()) (== b `(,car-b . ,cdr-b)) (== o b))
            
            ;; When both `a` and `b` are non-empty
            ((== a `(,car-a . ,cdr-a)) (== b `(,car-b . ,cdr-b)) (== o `(,car-o . ,cdr-o))
                (conde
                    ((== car-o car-a) (== z0 cdr-a) (== z1 b))
                    ((== car-o car-b) (== z0 a) (== z1 cdr-b)))
                    
                (riffleo z0 z1 cdr-o))))))
---

Another useful relation

--- main.mk.scm +=
(define same-lengtho (lambda (a b)
    (conde
        ((== a '()) (== b '()))
        ((fresh (x y z w)
            (== a `(,x . ,y))
            (== b `(,z . ,w))
            (same-lengtho y w))))))
---

@s Appendix B: immutable LinkedList implementation with constant-time, linkedList.Remove2Add1()

--- Remove2Add1Test.java
public class Remove2Add1Test {
    public static void Main(String[] args) {
        var dcba = new R2A1LinkedList<String>({"d", "c", "b", "a"});
        
        // Require callers to ensure that i < j
        var eba = dbca.remove2add1(0, 1, "e");
        var fd = edb.remove2add1(0, 2, "f");

        System.out.println("dbca: " + dbca.deepEquals({"d", "b", "c"));
        Syntem.out.println("eda: " + eda.deepEquals({"e", "b", "a"}));
        System.out.println("fd: " + eda.deepEquals({"f", "d"}));
    }
}
---

@s Appendix C: A translation of "proves" into Prolog

Hopefully this makes benchmarking easier. I don't know why filter_cbs is taking so long.

--- main.pl
riffle([], [], []).
riffle([A|As], [], [A|As]).
riffle([], [B|Bs], [B|Bs]).

riffle([A|As], [B|Bs], [A|Os]) :-
    riffle(As, [B|Bs], Os).

riffle([A|As], [B|Bs], [B|Os]) :-
    riffle([A|As], Bs, Os).



proof_step([], [], [], [], []).
proof_step([Step|Steps], 
           [Hleft|Hlefts],
           [Hright|Hrights],
           [C|Cbs],
           [Hout|Houts]) :-
    is_proof_step(Hleft, Hright, Hout, C, Step),
    proof_step(Steps, Hlefts, Hrights, Cbs, Houts).

is_proof_step(0, 0, 0, o, o).
is_proof_step(1, 0, 0, l, r1).
is_proof_step(1, 0, 1, o, b1).
is_proof_step(0, 1, 0, r, r2).
is_proof_step(0, 1, 1, o, b2).
is_proof_step(1, 1, 1, o, b).


proves(H, _, []) :- any_less_than_three(H).
proves(H, Cbs, [Step|Steps]) :-
    riffle([H1, H2], Hrest, H),
    riffle([HL], [HR], [H1, H2]),
    riffle([C], Crest, Cbs),
    proof_step(Step, HL, HR, C, Hout),
    filter_cbs(C, Crest, NewCbs),
    proves([Hout|Hrest], NewCbs, Steps).


any_less_than_three([H|_]) :- less_than_three(H).
any_less_than_three([_|Hs]) :- any_less_than_three(Hs).

less_than_three(X) :- size(X, z).
less_than_three(X) :- size(X, s(z)).
less_than_three(X) :- size(X, s(s(z))).
                           
size([], z).
size([0|Xs], N) :- size(Xs, N).
size([1|Xs], s(N)) :- size(Xs, N).


filter_cbs(_, [], []).
filter_cbs(X, [L|Ls], [L|Os]) :-
    overlaps(X, L, f),
    filter_cbs(X, Ls, Os).
filter_cbs(X, [L|Ls], Os) :-
    overlaps(X, L, t),
    filter_cbs(X, Ls, Os).

overlaps([], [], f).
overlaps([l|_], [l|_], t).
overlaps([l|_], [r|_], t).
overlaps([r|_], [l|_], t).
overlaps([r|_], [r|_], t).

overlaps([o|Xs], [_|Ys], B) :-
    overlaps(Xs, Ys, B).

overlaps([_|Xs], [o|Ys], B) :-
    overlaps(Xs, Ys, B).

k4_hypergraph([
	[1, 1, 1, 0],
	[0, 1, 1, 1]]).

k4_cbs([
	[l, o, o, r]]).

abc_hypergraph([
	[1, 0, 1, 1, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 1, 1]]).

abc_cbs([
    [l, r, o, o, o, o, o, o, o],
    [o, o, o, o, o, l, r, o, o],
    [o, o, o, o, l, o, r, o, o],
    [o, o, o, o, l, l, r, o, o],
    [o, o, o, l, o, o, r, o, o],
    [o, o, o, l, o, l, r, o, o],
    [o, o, o, l, l, o, r, o, o],
    [o, o, l, l, l, l, r, o, o]]).
---


@s Non-3-colorability and odd cycles
Proving a graph $G$ is not 3-colorable involves operations on the odd cycles contained in the graph. Therefore it would be useful to collect a set of sets of vertices, where the outer set contains the inner set if and only if there is an odd cycle in $G$ containing exactly those vertices in the inner set.

A hypergraph would be the most appropriate data structure for representing this set-of-sets since the innermost elements are vertices corresponding to vertices of the original graph $G$. Let's call this an **odd cycle hypergraph** $H$ that can be generated from $G$.

![test](../diagrams/odd-cycle-hypergraph.jpg "an odd cycle hypergraph")

For example, consider the above graph $G$, its 4 odd cycles, and its *odd cycle hypergraph*, $H$, which contains 4 hyperedges. It has 4 odd cycles drawn shown separately. Since two of the hyperedges have the exact same vertices, the hypergraph is [non-simple](https://en.wikipedia.org/wiki/Hypergraph#Properties_of_hypergraphs).


An efficient representation of a hypergraph is to use a two-dimensional boolean array where the rows are hyperedges and the columns are vertices. Each cell  $(e, v)$ holds the value `true` if vertex $v$ is included in the hyper-edge $e$, and `false` otherwise.




